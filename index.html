<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MIDI Timeline - Progressive & Choke</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü•Å</text></svg>">
  <style>
    /* --- Base --- */
    body { font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: #eee; padding: 20px; margin: 0; overflow: hidden; }
    h1 { margin-bottom: 10px; font-weight: 300; display: inline-block; margin-right: 20px; }
    
    /* --- Controls --- */
    #controls { margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
    button { padding: 8px 16px; background: #333; color: #fff; border: 1px solid #555; cursor: pointer; border-radius: 4px; }
    button:hover { background: #555; }
    button#resetBtn { background: #500; border-color: #700; }
    
    #status { font-size: 14px; color: #aaa; margin-left: 10px; font-variant-numeric: tabular-nums; }
    #deviceList { margin-bottom: 10px; font-size: 0.85em; color: #888; }

    /* --- Timeline --- */
    #timeline-wrapper {
      position: relative;
      height: 450px;
      background: #222;
      border: 1px solid #444;
      overflow: hidden; 
      box-shadow: inset 0 0 30px #000;
    }

    #timeline-content {
      position: relative;
      height: 100%;
      width: 1000000px; 
    }

    /* --- Elements --- */
    .grid-line {
      position: absolute; top: 0; bottom: 20px; width: 1px;
      border-left: 1px dashed rgba(255, 255, 255, 0.1); 
      z-index: 0;
    }
    .grid-label {
      position: absolute; bottom: 2px; font-size: 11px; color: #555;
      transform: translateX(-50%);
    }

    .note-line {
      position: absolute; top: 0; bottom: 0; width: 1px;
      background: rgba(255, 255, 255, 0.3); 
      z-index: 1; pointer-events: none;
    }

    /* Marqueur rond (Hits) */
    .note-marker {
      position: absolute; left: -6px; width: 12px; height: 12px;
      border-radius: 50%;
      z-index: 3;
      box-sizing: border-box;
    }
    .note-marker.rim { border: 2px solid #ff0000; box-shadow: 0 0 6px #ff0000; }

    /* Barre de cymbale */
    .note-bar {
      position: absolute; height: 14px;
      border-radius: 4px; opacity: 0.9; z-index: 2;
      /* D√©grad√© pour effet de tra√Æn√©e */
      background-image: linear-gradient(to right, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.1) 100%);
      border-left: 2px solid #fff;
      /* Pas de transition CSS ici car on anime la width en JS frame par frame */
    }
    
    /* Style ajout√© quand la note est √©touff√©e */
    .choked {
      border-right: 3px solid red; /* Marque rouge √† la fin */
      opacity: 0.6;
      filter: grayscale(0.5);
    }

  </style>
</head>
<body>

  <div>
    <h1>MIDI Monitor</h1>
    <span id="status">En attente...</span>
  </div>
  
  <div id="controls">
    <button id="connectBtn">Connecter MIDI</button>
    <button id="resetBtn">Reset</button>
  </div>
  <div id="deviceList"></div>

  <div id="timeline-wrapper">
    <div id="timeline-content"></div>
  </div>

  <script>
    // --- CONFIGURATION ---
    const PX_PER_MS = 0.3; 
    const SCREEN_OFFSET_RATIO = 0.85; 
    const CLEANUP_THRESHOLD_PX = 1000; 

    // Configuration des Notes
    const NOTE_CONFIG = {
      // KICK
      36: { y: 30,  color: '#ff3333', name: 'Kick' }, 
      
      // SNARE
      38: { y: 70,  color: '#eeeeee', name: 'Snare' },
      40: { y: 85,  color: '#eeeeee', name: 'Snare Rim', isRim: true },

      // TOMS
      43: { y: 130, color: '#228B22', name: 'Tom Basse' },
      58: { y: 140, color: '#228B22', name: 'Tom Basse Rim', isRim: true }, 
      45: { y: 170, color: '#32CD32', name: 'Tom Medium' },
      47: { y: 180, color: '#32CD32', name: 'Tom Medium Rim', isRim: true },
      48: { y: 210, color: '#98FB98', name: 'Tom Haut' },
      50: { y: 220, color: '#98FB98', name: 'Tom Haut Rim', isRim: true },

      // CYMBALES & HH
      42: { y: 260, color: '#FFA500', name: 'Hi-Hat Closed' }, 
      44: { y: 270, color: '#FFA500', name: 'Hi-Hat Pedal' },
      
      // HH Open : Dur√©e 1s (1000ms)
      46: { y: 280, color: '#FFD700', name: 'Hi-Hat Open', type: 'sustained', defaultDuration: 1000 },   
      
      // Autres cymbales : Dur√©e 2s (2000ms)
      51: { y: 320, color: '#FF8C00', name: 'Ride',    type: 'sustained', defaultDuration: 2000 },          
      49: { y: 350, color: '#FF4500', name: 'Crash 1', type: 'sustained', defaultDuration: 2000 },
      57: { y: 370, color: '#FF4500', name: 'Crash 2', type: 'sustained', defaultDuration: 2000 }
    };

    // --- VARIABLES ---
    let midiAccess = null;
    let startTime = null;
    let isRunning = false;
    let animationId = null;
    let lastDrawnSecond = -1;
    
    // activeNotes : contient les notes en train de "grandir"
    // structure : NoteMIDI -> { element, startX, maxDurationPx }
    const activeNotes = new Map(); 

    // DOM
    const wrapper = document.getElementById("timeline-wrapper");
    const content = document.getElementById("timeline-content");
    const statusEl = document.getElementById("status");
    const deviceList = document.getElementById("deviceList");

    // --- INIT ---
    window.addEventListener('load', init);
    document.getElementById("connectBtn").onclick = init;
    document.getElementById("resetBtn").onclick = resetTimeline;

    async function init() {
      try {
        midiAccess = await navigator.requestMIDIAccess();
        statusEl.textContent = "MIDI Connect√©. Pr√™t.";
        updateDeviceList();
        midiAccess.onstatechange = updateDeviceList;
        for (let input of midiAccess.inputs.values()) {
          input.onmidimessage = onMIDIMessage;
        }
      } catch (e) {
        statusEl.textContent = "Erreur acc√®s MIDI.";
      }
    }

    function updateDeviceList() {
      const inputs = Array.from(midiAccess.inputs.values());
      deviceList.innerHTML = inputs.length ? inputs.map(i => i.name).join(", ") : "Pas de source MIDI";
    }

    function resetTimeline() {
      content.innerHTML = '';
      startTime = null;
      lastDrawnSecond = -1;
      isRunning = false;
      activeNotes.clear();
      wrapper.scrollLeft = 0;
      if (animationId) cancelAnimationFrame(animationId);
      statusEl.textContent = "Reset effectu√©.";
    }

    // --- BOUCLE D'ANIMATION ---

    function startClock() {
      if (isRunning) return;
      isRunning = true;
      startTime = performance.now();
      drawLoop();
    }

    function drawLoop() {
      if (!isRunning) return;

      const now = performance.now();
      const timeElapsed = now - startTime;
      const currentHeadX = timeElapsed * PX_PER_MS;

      // 1. Mise √† jour des barres progressives
      // On parcourt toutes les notes "sustained" actives pour augmenter leur taille
      activeNotes.forEach((data, noteId) => {
        let currentWidth = currentHeadX - data.startX;
        
        // Si la dur√©e d√©passe le max pr√©vu, on arr√™te de faire grandir et on enl√®ve de la liste
        if (currentWidth >= data.maxDurationPx) {
          currentWidth = data.maxDurationPx;
          activeNotes.delete(noteId); // Note finie naturellement
        }
        
        data.element.style.width = currentWidth + "px";
      });

      // 2. Scroll Automatique
      const containerWidth = wrapper.clientWidth;
      const targetScroll = currentHeadX - (containerWidth * SCREEN_OFFSET_RATIO);
      if (targetScroll > 0) {
        wrapper.scrollLeft = targetScroll;
      }

      // 3. Dessiner la grille
      updateGrid(timeElapsed);

      // 4. Nettoyage
      cleanupDOM(wrapper.scrollLeft);

      animationId = requestAnimationFrame(drawLoop);
    }

    function updateGrid(currentTimeMs) {
      const currentSecond = Math.floor(currentTimeMs / 1000);
      if (currentSecond > lastDrawnSecond) {
        for (let s = lastDrawnSecond + 1; s <= currentSecond + 2; s++) { 
          const x = (s * 1000) * PX_PER_MS;
          createDOMElement("div", "grid-line", x, null, content);
          const label = createDOMElement("div", "grid-label", x, null, content);
          label.innerText = s + "s";
        }
        lastDrawnSecond = currentSecond;
      }
    }

    function cleanupDOM(scrollLeft) {
      const limit = scrollLeft - CLEANUP_THRESHOLD_PX;
      while (content.firstElementChild) {
        const el = content.firstElementChild;
        const left = parseFloat(el.style.left);
        let width = 0;
        if (el.style.width) width = parseFloat(el.style.width);

        if ((left + width) < limit) {
          content.removeChild(el);
        } else {
          break;
        }
      }
    }

    // --- LOGIQUE MIDI ---

    function onMIDIMessage(msg) {
      const [cmd, note, value] = msg.data;
      
      // D√©marrage horloge
      if (!isRunning && value > 0 && (cmd !== 248 && cmd !== 254)) {
        startClock();
      }
      if (!startTime) return;

      const eventTime = performance.now() - startTime;
      const x = eventTime * PX_PER_MS;

      // NOTE ON
      if ((cmd >= 144 && cmd <= 159) && value > 0) {
        handleNoteOn(note, x);
      }
      
      // POLYPHONIC AFTERTOUCH (169) -> CHOKE
      else if (cmd === 169 && value > 0) {
        chokeNote(note);
      }
    }

    function handleNoteOn(note, x) {
      const conf = NOTE_CONFIG[note];
      
      const y = conf ? conf.y : 400;
      const color = conf ? conf.color : '#666';
      const isRim = conf ? conf.isRim : false;
      const isSustained = conf && conf.type === 'sustained';
      const defaultDur = (conf && conf.defaultDuration) ? conf.defaultDuration : 1000;

      // Logique Hi-Hat : Si on appuie sur ferm√© (42/44), on √©touffe l'ouvert (46)
      if (note === 42 || note === 44) {
        chokeNote(46);
      }

      // Trait vertical de d√©part
      const lineEl = createDOMElement("div", "note-line", x, null, content);

      if (isSustained) {
        // Cymbale : On cr√©e une barre de largeur 0 qui va grandir
        const barEl = createDOMElement("div", "note-bar", x, y - 7, content);
        barEl.style.backgroundColor = color;
        barEl.style.width = "0px"; // D√©part √† 0
        
        // On l'ajoute √† activeNotes pour que la drawLoop la fasse grandir
        activeNotes.set(note, { 
          element: barEl, 
          startX: x, 
          maxDurationPx: defaultDur * PX_PER_MS 
        });

      } else {
        // Hit simple (Rond)
        const markerEl = document.createElement("div");
        markerEl.className = "note-marker" + (isRim ? " rim" : "");
        markerEl.style.bottom = (y - 6) + "px";
        markerEl.style.backgroundColor = color;
        markerEl.style.color = color;
        lineEl.appendChild(markerEl);
      }
    }

    function chokeNote(noteTarget) {
      // Si la note est en train de grandir (active), on l'arr√™te
      if (activeNotes.has(noteTarget)) {
        const data = activeNotes.get(noteTarget);
        
        // Ajouter la classe visuelle pour montrer le choke (bord rouge)
        data.element.classList.add("choked");
        
        // En supprimant de la Map, la drawLoop arr√™te de mettre √† jour la width.
        // La barre reste donc fig√©e √† sa taille actuelle.
        activeNotes.delete(noteTarget);
      }
    }

    function createDOMElement(tag, className, left, bottom, parent) {
      const el = document.createElement(tag);
      el.className = className;
      el.style.left = left + "px";
      if (bottom !== null) el.style.bottom = bottom + "px";
      parent.appendChild(el);
      return el;
    }

  </script>
</body>
</html>