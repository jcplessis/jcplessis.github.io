<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebXR — Scène 3D</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="info">
        <div><strong>WebXR — Scène 3D</strong></div>
        <div>Remarque : WebXR exige HTTPS (ou localhost). Si la page ne propose pas ENTER VR, vérifiez l'accès via HTTPS et que votre navigateur prend en charge WebXR.</div>
        <div id="debug"></div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        const debugEl = document.getElementById('debug');
        const log = (msg) => {
            debugEl.innerHTML += `<div>${msg}</div>`;
        };

        // Debug info
        log(`Support WebXR : ${'xr' in navigator}`);
        log(`Présence de navigator.xr : ${navigator.xr ? 'oui' : 'non'}`);
        if ('xr' in navigator && navigator.xr && navigator.xr.isSessionSupported) {
            navigator.xr.isSessionSupported('immersive-vr')
                .then(supported => log(`isSessionSupported('immersive-vr') : ${supported}`))
                .catch(err => log(`isSessionSupported error : ${err}`));
        }

        let renderer, scene, camera, cameraRig;
        init();
        animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x505050);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    // Ajout d'un groupe pour déplacer la caméra
    cameraRig = new THREE.Group();
    cameraRig.add(camera);
    scene.add(cameraRig);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    try {
        document.body.appendChild(VRButton.createButton(renderer));
    } catch (err) {
        log(`Erreur bouton VR : ${err}`);
    }

    const light = new THREE.HemisphereLight(0xffffff, 0x444444);
    light.position.set(0, 20, 0);
    scene.add(light);

    const grid = new THREE.GridHelper(10, 20, 0xffffff, 0xffffff);
    scene.add(grid);

    const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
    const boxMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(boxGeometry, boxMaterial);
    cube.position.set(0, 0.5, -2);
    scene.add(cube);

    window.addEventListener('resize', onWindowResize);
}

function render() {
    if (cameraRig) handleControllers();
    renderer.render(scene, camera);
}

function handleControllers() {
    const session = renderer.xr.getSession();
    if (!session) return;

    const inputSources = session.inputSources;
    const speed = 0.05;
    
    inputSources.forEach((input) => {
        if (input.gamepad && input.handedness) {
            const gp = input.gamepad;
            // axes[0] & axes[1] = gauche stick (X, Y)
            // axes[2] & axes[3] = droit stick (X, Y) (selon manette)
            // Ici on prend les axes 2 et 3 pour déplacement horizontal / avant-arrière
            // On peut ajuster si besoin.

            // Exemple : déplacer selon stick gauche (axes 0 et 1)
            let x = gp.axes[0] || 0;
            let y = gp.axes[1] || 0;

            // Inverser y pour avancer si besoin
            // Déplacer dans le plan XZ selon la direction où regarde la caméra
            if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                log("MOVE " + x + "," + y)
                const direction = new THREE.Vector3();

                // Déplacement latéral (x) = droite / gauche de la caméra
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), direction).normalize();

                // Appliquer déplacement au groupe contenant la caméra (cameraRig)
                cameraRig.position.addScaledVector(direction, -y * speed);
                cameraRig.position.addScaledVector(right, x * speed);
            }
        }
    });
}
        
      
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

       

    </script>
</body>
</html>
